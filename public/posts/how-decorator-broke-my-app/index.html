<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><script>!function(e,t){var n,s,o,i;t.__SV||(window.posthog=t,t._i=[],t.init=function(a,r,c){function d(e,t){var n=t.split(".");2==n.length&&(e=e[n[0]],t=n[1]),e[t]=function(){e.push([t].concat(Array.prototype.slice.call(arguments,0)))}}(s=e.createElement("script")).type="text/javascript",s.async=!0,s.src=r.api_host.replace(".i.posthog.com","-assets.i.posthog.com")+"/static/array.js",(i=e.getElementsByTagName("script")[0]).parentNode.insertBefore(s,i);var l=t;for(void 0!==c?l=t[c]=[]:c="posthog",l.people=l.people||[],l.toString=function(e){var t="posthog";return"posthog"!==c&&(t+="."+c),e||(t+=" (stub)"),t},l.people.toString=function(){return l.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags getFeatureFlag getFeatureFlagPayload reloadFeatureFlags group updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures getActiveMatchingSurveys getSurveys onSessionId".split(" "),n=0;n<o.length;n++)d(l,o[n]);t._i.push([a,r,c])},t.__SV=1)}(document,window.posthog||[]),posthog.init("phc_vxLUYaSwR9EKaAuLgPH3xmn605L4wA8ChJZtmwJEgiI",{api_host:"https://us.i.posthog.com",person_profiles:"identified_only"})</script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How a Decorator Crashed My Flask App: Lessons Learned | Suyog's personal blog</title>
<meta name=keywords content="python"><meta name=description content="TL;DR: Always use functools.wraps for your decorators.
Decorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I&rsquo;ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.
The Issue So we had a Flask API that was responsible for ML inference."><meta name=author content="Suyog"><link rel=canonical href=http://localhost:1313/posts/how-decorator-broke-my-app/><meta name=google-site-verification content="GTM-N8FH88H3"><link crossorigin=anonymous href=/assets/css/stylesheet.4c28a66a94bdf0c82a26d82167028400897c838afe288e620ef5588afed79ea4.css integrity="sha256-TCimapS98MgqJtghZwKEAIl8g4r+KI5iDvVYiv7XnqQ=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon_io/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon_io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon_io/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/favicon_io/apple_touch_icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/how-decorator-broke-my-app/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="How a Decorator Crashed My Flask App: Lessons Learned"><meta property="og:description" content="TL;DR: Always use functools.wraps for your decorators.
Decorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I&rsquo;ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.
The Issue So we had a Flask API that was responsible for ML inference."><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/how-decorator-broke-my-app/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-01T11:07:28+05:45"><meta property="article:modified_time" content="2024-07-01T11:07:28+05:45"><meta property="og:site_name" content="Suyog's personal blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="How a Decorator Crashed My Flask App: Lessons Learned"><meta name=twitter:description content="TL;DR: Always use functools.wraps for your decorators.
Decorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I&rsquo;ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.
The Issue So we had a Flask API that was responsible for ML inference."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"How a Decorator Crashed My Flask App: Lessons Learned","item":"http://localhost:1313/posts/how-decorator-broke-my-app/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How a Decorator Crashed My Flask App: Lessons Learned","name":"How a Decorator Crashed My Flask App: Lessons Learned","description":"TL;DR: Always use functools.wraps for your decorators.\nDecorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I\u0026rsquo;ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.\nThe Issue So we had a Flask API that was responsible for ML inference.","keywords":["python"],"articleBody":" TL;DR: Always use functools.wraps for your decorators.\nDecorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I’ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.\nThe Issue So we had a Flask API that was responsible for ML inference. Here is what the rough structure of the project looked like:\nproject/ ├── app/ │ ├── utils/ │ ├── __init.py__ │ ├── decorators.py | ├── __init.py__ │ ├── app.py │ ├── ... app/app.py\n# all other imports .... from utils.decorators import timeit @app.route('/v1/predict/', methods=['POST']) @timeit def predict_v1(...): # do something So as you can see above, we had a fairly simple decorator for timing the execution of an endpoint. Here is what a rough implementation of the decorator looked like:\napp/decorators.py\nimport time def timeit(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() elapsed_time = end_time - start_time print(f\"Function '{func.__name__}' executed in {elapsed_time:.4f} seconds\") return result return wrapper For those Python wizards out there who can immediately identify the issue by seeing the snippets above, feel free to skip the rest of this article (you guys have my respect). For those who didn’t spot the issue from the snippets above, don’t worry—you’re in the right place! Let’s walk through it together so you can understand the problem.\nThis application was working fine for a long time until I decided to modify some pre-processing logic in the ML inference. I did not directly update the current endpoint as the changes were not quite backward compatible. So I created a /v2/ endpoint for the new changes. My application now looked something like this:\napp/app.py\n# all other imports .... from utils.decorators import timeit @app.route('/v1/predict/', methods=['POST']) @timeit def predict_v1(...): # do something @app.route('/v2/predict/', methods=['POST']) @timeit def predict_v2(...): # do something, but differently ;) Everything looked good, I had tested the new logic in isolation, and it was working exactly how I needed it to. So, with full confidence I started my flask server with flask run and the server instantly crashed.\nPuzzled as to why this happened, I checked the logs. There, I saw a new error message. It wasn’t the typical kind of message I was used to seeing at my job:\nAssertionError: View function mapping is overwriting an existing endpoint function: wrapper Understanding the Issue Ok let’s break the error message.\nThe first part of the message AssertionError: View function mapping is overwriting an existing endpoint function indicates that something went wrong in the Flask server regarding the route definitions. This message basically says that there are two routes with the same function name which is not allowed in Flask. You can refer to this article to understand more about Flask routes.\nBut how did this happen? I had explicitly named the functions predict_v1 and predict_v2. Why was this assertion error raised?\nAhh, the error message points to the culprit too: the function name wrapper.\nAfter spending some time, I figured out what had happened: When we applied the timeit decorator to our functions, the decorator returned a new function named wrapper. This meant that both of our route functions predict_v1 and predict_v2, were being replaced by a single function named wrapper. Flask uses the function name as the endpoint name by default. Since both decorated functions were now named wrapper, Flask tried to register multiple route functions with the same name, causing the AssertionError.\nThe Solution After understanding the issue, my immediate intuitive solution was to explicitly rename the wrapper function to the original function name inside the decorator before returning it.\napp/decorators.py\nimport time def timeit(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() elapsed_time = end_time - start_time print(f\"Function '{func.__name__}' executed in {elapsed_time:.4f} seconds\") return result wrapper.__name__ = func.__name__ # rename the function name before returning return wrapper And to my surprise, this worked! (Ah, that feeling you get when your code works on the first try). But I wasn’t satisfied with this solution. I wanted to understand it more. How could such a thing even exist? I am surely not the first programmer who has used decorators on their Flask routes. How could such an issue arise? I have been using decorators for over a couple of years, but why did this never occur to me? I was at the office, so I called my colleague Ashish to tell him about my newfound issue (actually, it was he who had originally written that decorator). Me being me, I just showed him the original decorator and asked him what’s wrong here. He took some time, carefully read each and every line, and answered, “There’s no functools.wraps in that decorator.”\nHow did I not see that? I have been using functools.wraps to create decorators, but really without understanding the why aspect of it. So, again I modified my decorator with functools.wraps and removed the function renaming part:\napp/decorators.py\nimport time from functools import wraps def timeit(func): @wraps(func) def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() elapsed_time = end_time - start_time print(f\"Function '{func.__name__}' executed in {elapsed_time:.4f} seconds\") return result return wrapper My Flask application did not crash this time! Now I wanted to understand what exactly does functools.wraps do.\nUnderstanding functools.wraps Being the unsensible person I am, instead of searching the documentation of functools.wraps, I directly opened the source code of it.\ndef wraps(wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Decorator factory to apply update_wrapper() to a wrapper function Returns a decorator that invokes update_wrapper() with the decorated function as the wrapper argument and the arguments to wraps() as the remaining arguments. Default arguments are as for update_wrapper(). This is a convenience function to simplify applying partial() to update_wrapper(). \"\"\" return partial(update_wrapper, wrapped=wrapped, assigned=assigned, updated=updated) It returns a partial of the function update_wrapper. There was nothing I could make out of this function alone. So I moved to the implementation of update_wrapper. This is where things got interesting.\nWRAPPER_ASSIGNMENTS = ('__module__', '__name__', '__qualname__', '__doc__', '__annotations__', '__type_params__') WRAPPER_UPDATES = ('__dict__',) def update_wrapper(wrapper, wrapped, assigned = WRAPPER_ASSIGNMENTS, updated = WRAPPER_UPDATES): \"\"\"Update a wrapper function to look like the wrapped function wrapper is the function to be updated wrapped is the original function assigned is a tuple naming the attributes assigned directly from the wrapped function to the wrapper function (defaults to functools.WRAPPER_ASSIGNMENTS) updated is a tuple naming the attributes of the wrapper that are updated with the corresponding attribute from the wrapped function (defaults to functools.WRAPPER_UPDATES) \"\"\" for attr in assigned: try: value = getattr(wrapped, attr) except AttributeError: pass else: setattr(wrapper, attr, value) for attr in updated: getattr(wrapper, attr).update(getattr(wrapped, attr, {})) # Issue #17482: set __wrapped__ last so we don't inadvertently copy it # from the wrapped function when updating __dict__ wrapper.__wrapped__ = wrapped # Return the wrapper so this can be used as a decorator via partial() return wrapper update_wrapper updates a wrapper function to look like the wrapped function. It copies the __module__, __name__, __qualname__, __doc__, and __annotations__ attributes from the wrapped function to the wrapper function. This default list is defined in WRAPPER_ASSIGNMENTS. It updates the __dict__ of the wrapper with all elements from the wrapped function’s __dict__, based on WRAPPER_UPDATES. It sets a new __wrapped__ attribute on the wrapper, pointing to the original function. In a nutshell, functools.wrap ensures that the decorated function retains the original function’s signature, documentation, and other attributes. (So bascially an extented version of my intial solution 😅).\nIn conclusion, encountering issues like this serves as a valuable reminder of the subtle complexities and hidden layers that lie beneath the surface of programming. It shows that no matter how much we learn, there’s always more to discover! Keep learning, cheers 🥂.\n","wordCount":"1308","inLanguage":"en","datePublished":"2024-07-01T11:07:28+05:45","dateModified":"2024-07-01T11:07:28+05:45","author":{"@type":"Person","name":"Suyog"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/how-decorator-broke-my-app/"},"publisher":{"@type":"Organization","name":"Suyog's personal blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon_io/favicon-32x32.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/about/ title=about><span>about</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">How a Decorator Crashed My Flask App: Lessons Learned</h1><div class=post-meta><span title='2024-07-01 11:07:28 +0545 +0545'>July 1, 2024</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;<a href=/tags/python> python</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#the-issue>The Issue</a></li><li><a href=#understanding-the-issue>Understanding the Issue</a></li><li><a href=#the-solution>The Solution</a></li><li><a href=#understanding-functoolswraps>Understanding <code>functools.wraps</code></a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>TL;DR: Always use <code>functools.wraps</code> for your decorators.</p></blockquote><p>Decorators in python are wonderful. They let you modify or extend the behavior of functions or methods without permanently modifying their source code. I&rsquo;ve used them in several places in my code to add features to my functions. But recently, I came across a weird, or rather interesting, bug that I felt was worth sharing.</p><h2 id=the-issue>The Issue<a hidden class=anchor aria-hidden=true href=#the-issue>#</a></h2><p>So we had a Flask API that was responsible for ML inference. Here is what the rough structure of the project looked like:</p><pre tabindex=0><code>project/
├── app/
│   ├── utils/
│       ├── __init.py__
│       ├── decorators.py
|   ├── __init.py__
│   ├── app.py
│   ├── ...
</code></pre><p><code>app/app.py</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># all other imports</span>
</span></span><span class=line><span class=cl><span class=o>....</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>utils.decorators</span> <span class=kn>import</span> <span class=n>timeit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/v1/predict/&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;POST&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nd>@timeit</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict_v1</span><span class=p>(</span><span class=o>...</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># do something</span>
</span></span></code></pre></div><p>So as you can see above, we had a fairly simple decorator for timing the execution of an endpoint. Here is what a rough implementation of the decorator looked like:</p><p><code>app/decorators.py</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>timeit</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>end_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>elapsed_time</span> <span class=o>=</span> <span class=n>end_time</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Function &#39;</span><span class=si>{</span><span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s2>&#39; executed in </span><span class=si>{</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><p>For those Python wizards out there who can immediately identify the issue by seeing the snippets above, feel free to skip the rest of this article (you guys have my respect). For those who didn&rsquo;t spot the issue from the snippets above, don&rsquo;t worry—you&rsquo;re in the right place! Let&rsquo;s walk through it together so you can understand the problem.</p><p>This application was working fine for a long time until I decided to modify some pre-processing logic in the ML inference. I did not directly update the current endpoint as the changes were not quite backward compatible. So I created a <code>/v2/</code> endpoint for the new changes. My application now looked something like this:</p><p><code>app/app.py</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># all other imports</span>
</span></span><span class=line><span class=cl><span class=o>....</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>utils.decorators</span> <span class=kn>import</span> <span class=n>timeit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/v1/predict/&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;POST&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nd>@timeit</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict_v1</span><span class=p>(</span><span class=o>...</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># do something</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nd>@app.route</span><span class=p>(</span><span class=s1>&#39;/v2/predict/&#39;</span><span class=p>,</span> <span class=n>methods</span><span class=o>=</span><span class=p>[</span><span class=s1>&#39;POST&#39;</span><span class=p>])</span>
</span></span><span class=line><span class=cl><span class=nd>@timeit</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>predict_v2</span><span class=p>(</span><span class=o>...</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=c1># do something, but differently ;)</span>
</span></span></code></pre></div><p>Everything looked good, I had tested the new logic in isolation, and it was working exactly how I needed it to. So, with full confidence I started my flask server with <code>flask run</code> and the server instantly crashed.</p><p>Puzzled as to why this happened, I checked the logs. There, I saw a new error message. It wasn&rsquo;t the typical kind of message I was used to seeing at my job:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>AssertionError: View <span class=k>function</span> mapping is overwriting an existing endpoint <span class=k>function</span>: wrapper
</span></span></code></pre></div><div style=display:flex;justify-content:center;align-items:center><img src=/img/decorator/crash_meme.jpg alt="crash meme lol"></div><h2 id=understanding-the-issue>Understanding the Issue<a hidden class=anchor aria-hidden=true href=#understanding-the-issue>#</a></h2><p>Ok let&rsquo;s break the error message.</p><p>The first part of the message <code>AssertionError: View function mapping is overwriting an existing endpoint function</code> indicates that something went wrong in the Flask server regarding the route definitions. This message basically says that there are two routes with the same function name which is not allowed in Flask. You can refer to <a href=https://dev.to/emma_donery/python-flask-app-routing-3l57>this</a> article to understand more about Flask routes.</p><p>But how did this happen? I had explicitly named the functions <code>predict_v1</code> and <code>predict_v2</code>. Why was this assertion error raised?</p><p>Ahh, the error message points to the culprit too: the function name <code>wrapper</code>.</p><p>After spending some time, I figured out what had happened: When we applied the <code>timeit</code> decorator to our functions, the decorator returned a new function named <code>wrapper</code>. This meant that both of our route functions <code>predict_v1</code> and <code>predict_v2</code>, were being replaced by a single function named <code>wrapper</code>. Flask uses the function name as the endpoint name by default. Since both decorated functions were now named <code>wrapper</code>, Flask tried to register multiple route functions with the same name, causing the <code>AssertionError</code>.</p><h2 id=the-solution>The Solution<a hidden class=anchor aria-hidden=true href=#the-solution>#</a></h2><p>After understanding the issue, my immediate intuitive solution was to explicitly rename the wrapper function to the original function name inside the decorator before returning it.</p><p><code>app/decorators.py</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>timeit</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>end_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>elapsed_time</span> <span class=o>=</span> <span class=n>end_time</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Function &#39;</span><span class=si>{</span><span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s2>&#39; executed in </span><span class=si>{</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    <span class=n>wrapper</span><span class=o>.</span><span class=vm>__name__</span> <span class=o>=</span> <span class=n>func</span><span class=o>.</span><span class=vm>__name__</span> <span class=c1># rename the function name before returning</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><p>And to my surprise, this worked! (Ah, that feeling you get when your code works on the first try). But I wasn&rsquo;t satisfied with this solution. I wanted to understand it more. How could such a thing even exist? I am surely not the first programmer who has used decorators on their Flask routes. How could such an issue arise? I have been using decorators for over a couple of years, but why did this never occur to me? I was at the office, so I called my colleague <a href=https://asubedi.com.np/>Ashish</a> to tell him about my newfound issue (actually, it was he who had originally written that decorator). Me being me, I just showed him the original decorator and asked him what&rsquo;s wrong here. He took some time, carefully read each and every line, and answered, &ldquo;There&rsquo;s no <code>functools.wraps</code> in that decorator.&rdquo;</p><p>How did I not see that? I have been using <code>functools.wraps</code> to create decorators, but really without understanding the why aspect of it. So, again I modified my decorator with <code>functools.wraps</code> and removed the function renaming part:</p><p><code>app/decorators.py</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>time</span>
</span></span><span class=line><span class=cl><span class=kn>from</span> <span class=nn>functools</span> <span class=kn>import</span> <span class=n>wraps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>timeit</span><span class=p>(</span><span class=n>func</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nd>@wraps</span><span class=p>(</span><span class=n>func</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>def</span> <span class=nf>wrapper</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=n>start_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>result</span> <span class=o>=</span> <span class=n>func</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>end_time</span> <span class=o>=</span> <span class=n>time</span><span class=o>.</span><span class=n>time</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>elapsed_time</span> <span class=o>=</span> <span class=n>end_time</span> <span class=o>-</span> <span class=n>start_time</span>
</span></span><span class=line><span class=cl>        <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s2>&#34;Function &#39;</span><span class=si>{</span><span class=n>func</span><span class=o>.</span><span class=vm>__name__</span><span class=si>}</span><span class=s2>&#39; executed in </span><span class=si>{</span><span class=n>elapsed_time</span><span class=si>:</span><span class=s2>.4f</span><span class=si>}</span><span class=s2> seconds&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><p>My Flask application did not crash this time!
Now I wanted to understand what exactly does <code>functools.wraps</code> do.</p><div style=display:flex;justify-content:center;align-items:center><img src=/img/decorator/mind-blown.gif alt="mind=blown"></div><h2 id=understanding-functoolswraps>Understanding <code>functools.wraps</code><a hidden class=anchor aria-hidden=true href=#understanding-functoolswraps>#</a></h2><p>Being the unsensible person I am, instead of searching the documentation of <code>functools.wraps</code>, I directly opened the source code of it.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>wraps</span><span class=p>(</span><span class=n>wrapped</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>assigned</span> <span class=o>=</span> <span class=n>WRAPPER_ASSIGNMENTS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>          <span class=n>updated</span> <span class=o>=</span> <span class=n>WRAPPER_UPDATES</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Decorator factory to apply update_wrapper() to a wrapper function
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>       Returns a decorator that invokes update_wrapper() with the decorated
</span></span></span><span class=line><span class=cl><span class=s2>       function as the wrapper argument and the arguments to wraps() as the
</span></span></span><span class=line><span class=cl><span class=s2>       remaining arguments. Default arguments are as for update_wrapper().
</span></span></span><span class=line><span class=cl><span class=s2>       This is a convenience function to simplify applying partial() to
</span></span></span><span class=line><span class=cl><span class=s2>       update_wrapper().
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>partial</span><span class=p>(</span><span class=n>update_wrapper</span><span class=p>,</span> <span class=n>wrapped</span><span class=o>=</span><span class=n>wrapped</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>assigned</span><span class=o>=</span><span class=n>assigned</span><span class=p>,</span> <span class=n>updated</span><span class=o>=</span><span class=n>updated</span><span class=p>)</span>
</span></span></code></pre></div><p>It returns a partial of the function <code>update_wrapper</code>. There was nothing I could make out of this function alone. So I moved to the implementation of <code>update_wrapper</code>. This is where things got interesting.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>WRAPPER_ASSIGNMENTS</span> <span class=o>=</span> <span class=p>(</span><span class=s1>&#39;__module__&#39;</span><span class=p>,</span> <span class=s1>&#39;__name__&#39;</span><span class=p>,</span> <span class=s1>&#39;__qualname__&#39;</span><span class=p>,</span> <span class=s1>&#39;__doc__&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                       <span class=s1>&#39;__annotations__&#39;</span><span class=p>,</span> <span class=s1>&#39;__type_params__&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>WRAPPER_UPDATES</span> <span class=o>=</span> <span class=p>(</span><span class=s1>&#39;__dict__&#39;</span><span class=p>,)</span>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>update_wrapper</span><span class=p>(</span><span class=n>wrapper</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>wrapped</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>assigned</span> <span class=o>=</span> <span class=n>WRAPPER_ASSIGNMENTS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                   <span class=n>updated</span> <span class=o>=</span> <span class=n>WRAPPER_UPDATES</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;&#34;&#34;Update a wrapper function to look like the wrapped function
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>       wrapper is the function to be updated
</span></span></span><span class=line><span class=cl><span class=s2>       wrapped is the original function
</span></span></span><span class=line><span class=cl><span class=s2>       assigned is a tuple naming the attributes assigned directly
</span></span></span><span class=line><span class=cl><span class=s2>       from the wrapped function to the wrapper function (defaults to
</span></span></span><span class=line><span class=cl><span class=s2>       functools.WRAPPER_ASSIGNMENTS)
</span></span></span><span class=line><span class=cl><span class=s2>       updated is a tuple naming the attributes of the wrapper that
</span></span></span><span class=line><span class=cl><span class=s2>       are updated with the corresponding attribute from the wrapped
</span></span></span><span class=line><span class=cl><span class=s2>       function (defaults to functools.WRAPPER_UPDATES)
</span></span></span><span class=line><span class=cl><span class=s2>    &#34;&#34;&#34;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>assigned</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>try</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>value</span> <span class=o>=</span> <span class=nb>getattr</span><span class=p>(</span><span class=n>wrapped</span><span class=p>,</span> <span class=n>attr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>except</span> <span class=ne>AttributeError</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=k>pass</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=nb>setattr</span><span class=p>(</span><span class=n>wrapper</span><span class=p>,</span> <span class=n>attr</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>attr</span> <span class=ow>in</span> <span class=n>updated</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nb>getattr</span><span class=p>(</span><span class=n>wrapper</span><span class=p>,</span> <span class=n>attr</span><span class=p>)</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=nb>getattr</span><span class=p>(</span><span class=n>wrapped</span><span class=p>,</span> <span class=n>attr</span><span class=p>,</span> <span class=p>{}))</span>
</span></span><span class=line><span class=cl>    <span class=c1># Issue #17482: set __wrapped__ last so we don&#39;t inadvertently copy it</span>
</span></span><span class=line><span class=cl>    <span class=c1># from the wrapped function when updating __dict__</span>
</span></span><span class=line><span class=cl>    <span class=n>wrapper</span><span class=o>.</span><span class=n>__wrapped__</span> <span class=o>=</span> <span class=n>wrapped</span>
</span></span><span class=line><span class=cl>    <span class=c1># Return the wrapper so this can be used as a decorator via partial()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>wrapper</span>
</span></span></code></pre></div><ul><li><code>update_wrapper</code> updates a wrapper function to look like the wrapped function.</li><li>It copies the <code>__module__</code>, <code>__name__</code>, <code>__qualname__</code>, <code>__doc__</code>, and <code>__annotations__</code> attributes from the wrapped function to the wrapper function. This default list is defined in <code>WRAPPER_ASSIGNMENTS</code>.</li><li>It updates the <code>__dict__</code> of the wrapper with all elements from the wrapped function&rsquo;s <code>__dict__</code>, based on <code>WRAPPER_UPDATES</code>.</li><li>It sets a new <code>__wrapped__</code> attribute on the wrapper, pointing to the original function.</li></ul><p>In a nutshell, <code>functools.wrap</code> ensures that the decorated function retains the original function&rsquo;s signature, documentation, and other attributes. (So bascially an extented version of my intial solution 😅).</p><p>In conclusion, encountering issues like this serves as a valuable reminder of the subtle complexities and hidden layers that lie beneath the surface of programming. It shows that no matter how much we learn, there&rsquo;s always more to discover! Keep learning, cheers 🥂.</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/python/>Python</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/dspy-prompt-tuning/><span class=title>Next »</span><br><span>Prompt Tuning with DSPy</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=suyogdahal/suyogdahal.github.io data-repo-id=R_kgDOMFtnVQ data-category=General data-category-id=DIC_kwDOMFtnVc4CgAkO data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=en data-loading=lazy crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Suyog's personal blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>